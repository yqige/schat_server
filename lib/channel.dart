import 'controller/heroes_controller.dart';import 'controller/identity_controller.dart';import 'controller/register_controller.dart';import 'controller/user_controller.dart';import 'model/user.dart';import 'schat_server.dart';import 'utility/html_template.dart';/// This type initializes an application.////// Override methods in this class to set up routes and initialize services like/// database connections. See http://aqueduct.io/docs/http/channel/.class SchatServerChannel extends ApplicationChannel    implements AuthRedirectControllerDelegate {  final HTMLRenderer htmlRenderer = HTMLRenderer();  AuthServer authServer;  ManagedContext context;  Map<int,WebSocket> connectedSockets;  /// Initialize services in this method.  ///  /// Implement this method to initialize services, read values from [options]  /// and any other initialization required before constructing [entryPoint].  ///  /// This method is invoked prior to [entryPoint] being accessed.  @override  Future prepare() async {    logger.parent.level = Level.ALL;    logger.onRecord.listen(        (rec) => print("${rec.time} ${rec.loggerName}[${rec.level.name}] : ${rec.message} ${rec.error ?? ""} ${rec.stackTrace ?? ""}"));    connectedSockets= new Map();    final config = SchatServerConfiguration(options.configurationFilePath);    context = contextWithConnectionInfo(config.database);    messageHub.listen((event) {      if (event is Map && event["event"] == "websocket_broadcast") {        connectedSockets.forEach((userId,socket) {          socket.add(event["message"]);        });      }    });    final authStorage = ManagedAuthDelegate<User>(context);    authServer = AuthServer(authStorage);  }//  @override//  SecurityContext get securityContext {//    return SecurityContext()//      ..usePrivateKey("server.key", password: "1234")//      ..useCertificateChain("server.crt", password: "1234");//  }  /// Construct the request channel.  ///  /// Return an instance of some [Controller] that will be the initial receiver  /// of all [Request]s.  ///  /// This method is invoked after [prepare].  @override  Controller get entryPoint {    final router = Router();    /* OAuth 2.0 Endpoints */    router.route("/auth/token").link(() => AuthController(authServer));    router        .route("/auth/form")        .link(() => AuthRedirectController(authServer, delegate: this));    /* Create an account */    router        .route("/register")        .link(() => Authorizer.basic(authServer))        .link(() => RegisterController(context, authServer));    /* Gets profile for user with bearer token */    router        .route("/me")        .link(() => Authorizer.bearer(authServer))        .link(() => IdentityController(context));    /* Gets all users or one specific user by id */    router        .route("/users/[:id]")        .link(() => Authorizer.bearer(authServer))        .link(() => UserController(context, authServer));    router        .route('/heroes/[:id]')        .link(() => HeroesController(context));    router        .route("/connect")        .link(() => Authorizer(authServer))        .linkFunction((request) async {          if(WebSocketTransformer.isUpgradeRequest(request.raw)){            final userID = request.authorization.ownerID;            await WebSocketTransformer.upgrade(request.raw).then((webSocket){              connectedSockets.addAll({userID: webSocket});              webSocket.listen(onChatMessage);            });          }    });    return router;  }//  void handleEvent(dynamic event, {int fromUserID}) {//    var incoming = json.decode(Utf8Decoder.decode(event));//    var outgoing = utf8.encode(json.encode({//    "text": incoming["text"],//    ...//    }));////    connections.keys//        .where((userID) => userID != fromUserID)//        .forEach((userID) {//      var connection = connections[userID];//      connection.add(outgoing);//    });//  }  //处理消息  void onChatMessage(dynamic message) {    //给所有客户端回复当前客户端说了什么    connectedSockets.forEach((userID,webSocket) {      //判断是否有关闭代码，如果没有证明客户端当前未关闭，给它回复      if (webSocket.closeCode == null) {//        //回复客户端一条消息        webSocket.add('服务器回复: XX:$message');      }    });    messageHub.add({"event": "websocket_broadcast", "message": message});  }  /*   * Helper methods   */  ManagedContext contextWithConnectionInfo(      DatabaseConfiguration connectionInfo) {    final dataModel = ManagedDataModel.fromCurrentMirrorSystem();    final psc = PostgreSQLPersistentStore(        connectionInfo.username,        connectionInfo.password,        connectionInfo.host,        connectionInfo.port,        connectionInfo.databaseName);    return ManagedContext(dataModel, psc);  }  @override  Future<String> render(AuthRedirectController forController, Uri requestUri,      String responseType, String clientID, String state, String scope) async {    final map = {      "response_type": responseType,      "client_id": clientID,      "state": state    };    map["path"] = requestUri.path;    if (scope != null) {      map["scope"] = scope;    }    return htmlRenderer.renderHTML("web/login.html", map);  }}/// An instance of this class represents values from a configuration/// file specific to this application.////// Configuration files must have key-value for the properties in this class./// For more documentation on configuration files, see/// https://pub.dartlang.org/packages/safe_config.class SchatServerConfiguration extends Configuration {  SchatServerConfiguration(String fileName) : super.fromFile(File(fileName));  DatabaseConfiguration database;  int port;}