import 'package:schat_server/model/message.dart';import 'package:schat_server/server/auth_server.dart';import 'controller/heroes_controller.dart';import 'controller/identity_controller.dart';import 'controller/register_controller.dart';import 'controller/user_controller.dart';import 'model/user.dart';import 'schat_server.dart';import 'utility/html_template.dart';/// This type initializes an application.////// Override methods in this class to set up routes and initialize services like/// database connections. See http://aqueduct.io/docs/http/channel/.class SchatServerChannel extends ApplicationChannel    implements AuthRedirectControllerDelegate {  final HTMLRenderer htmlRenderer = HTMLRenderer();  AuthServer authServer;  BbAuthServer bbAuthServer;  ManagedContext context;  Map<int,WebSocket> connectedSockets;  /// Initialize services in this method.  ///  /// Implement this method to initialize services, read values from [options]  /// and any other initialization required before constructing [entryPoint].  ///  /// This method is invoked prior to [entryPoint] being accessed.  @override  Future prepare() async {    logger.parent.level = Level.ALL;    logger.onRecord.listen(        (rec) => print("${rec.time} ${rec.loggerName}[${rec.level.name}] : ${rec.message} ${rec.error ?? ""} ${rec.stackTrace ?? ""}"));    connectedSockets= {};    final config = SchatServerConfiguration(options.configurationFilePath);    context = contextWithConnectionInfo(config.database);    messageHub.listen((event) {      if (event is Map && event["event"] == "websocket_broadcast") {        final Message ma = event['message'] as Message;        connectedSockets.forEach((userId,socket) {          if(ma.to == userId){            socket.add(event["message"]);          }        });      }    });    final authStorage = ManagedAuthDelegate<User>(context);    authServer = AuthServer(authStorage);    final bbAuthStorage = ManagedAuthDelegate<User>(context);    bbAuthServer = BbAuthServer(bbAuthStorage);  }//  @override//  SecurityContext get securityContext {//    return SecurityContext()//      ..usePrivateKey("server.key", password: "1234")//      ..useCertificateChain("server.crt", password: "1234");//  }  /// Construct the request channel.  ///  /// Return an instance of some [Controller] that will be the initial receiver  /// of all [Request]s.  ///  /// This method is invoked after [prepare].  @override  Controller get entryPoint {    final router = Router();    /* OAuth 2.0 Endpoints */    router.route("/auth/token").link(() => AuthController(authServer));    router        .route("/auth/form")        .link(() => AuthRedirectController(authServer, delegate: this));    /* Create an account */    router        .route("/register")//        .link(() => Authorizer.basic(authServer))        .link(() => RegisterController(context, authServer, null));    /* Create an account */    router        .route("/register/:code")        .link(() => RegisterController(context, null, bbAuthServer));    /* Gets profile for user with bearer token */    router        .route("/me")        .link(() => Authorizer.bearer(authServer))        .link(() => IdentityController(context));    /* Gets all users or one specific user by id */    router        .route("/users/[:id]")        .link(() => Authorizer.bearer(authServer))        .link(() => UserController(context, authServer));    router        .route('/heroes/[:id]')        .link(() => HeroesController(context));    router        .route("/connect")        .link(() => Authorizer(authServer))        .linkFunction((request) async {      if(WebSocketTransformer.isUpgradeRequest(request.raw)){        final userID = request.authorization.ownerID;        print('userID:${userID}');        await WebSocketTransformer.upgrade(request.raw).then((webSocket){//              connectedSockets.addAll({userID: webSocket});          webSocket.listen((event) => onChatMessage(event, fromUserID: userID));          connectedSockets[userID] = webSocket;        });      }      return null;    });    return router;  }//  void handleEvent(dynamic event, {int fromUserID}) {//    var incoming = json.decode(Utf8Decoder.decode(event));//    var outgoing = utf8.encode(json.encode({//    "text": incoming["text"],//    ...//    }));////    connections.keys//        .where((userID) => userID != fromUserID)//        .forEach((userID) {//      var connection = connections[userID];//      connection.add(outgoing);//    });//  }  //处理消息  void onChatMessage(dynamic message, {int fromUserID}) {    final Message ma = Message(message);    //给目标客户端回复当前客户端说了什么    connectedSockets.forEach((userId, webSocket){      if(userId == ma.to) {        //判断是否有关闭代码，如果没有证明客户端当前未关闭，给它回复        if (webSocket.closeCode == null) {//        //回复客户端一条消息          webSocket.add('服务器回复: XX:$ma');        }      }    });    messageHub.add({"event": "websocket_broadcast", "message": ma});  }  /*   * Helper methods   */  ManagedContext contextWithConnectionInfo(      DatabaseConfiguration connectionInfo) {    final dataModel = ManagedDataModel.fromCurrentMirrorSystem();    final psc = PostgreSQLPersistentStore(        connectionInfo.username,        connectionInfo.password,        connectionInfo.host,        connectionInfo.port,        connectionInfo.databaseName);    return ManagedContext(dataModel, psc);  }  @override  Future<String> render(AuthRedirectController forController, Uri requestUri,      String responseType, String clientID, String state, String scope) async {    final map = {      "response_type": responseType,      "client_id": clientID,      "state": state    };    map["path"] = requestUri.path;    if (scope != null) {      map["scope"] = scope;    }    return htmlRenderer.renderHTML("web/login.html", map);  }}/// An instance of this class represents values from a configuration/// file specific to this application.////// Configuration files must have key-value for the properties in this class./// For more documentation on configuration files, see/// https://pub.dartlang.org/packages/safe_config.class SchatServerConfiguration extends Configuration {  SchatServerConfiguration(String fileName) : super.fromFile(File(fileName));  DatabaseConfiguration database;  int port;}